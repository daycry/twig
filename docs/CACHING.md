# Twig Caching & Persistence Architecture for CodeIgniter 4

This document explains every caching/persistence layer implemented in this library: what it stores, how it is keyed, when it is read/written, and how to clear or tune it.

> Summary: There are **five** persistence domains plus **one optional acceleration layer (APCu)**
> 1. Compiled template bytecode (Twig compiled PHP classes)
> 2. Compile Index (logical template -> compiled flag map)
> 3. Template Discovery statistics & (optionally) full template list snapshot
> 4. Warmup summary state
> 5. Invalidation history (last + cumulative)
> 6. (Optional) APCu list cache for discovery list reuse across PHP processes

Caching backend is auto-detected: if `service('cache')` returns a handler, CI cache is used; otherwise the filesystem is used.

---
## 1. Compiled Template Cache
Compiled templates are PHP classes generated by Twig. The library decides at runtime:

| Backend (auto) | Condition | Storage | Clearing Mechanism |
|----------------|-----------|---------|--------------------|
| CI Cache | Cache service available | Entries in configured CI cache handler (Redis/Memcached...) | Adapter clear + key deletions |
| File | No cache service | Files under `WRITEPATH/cache/twig` (or custom `cachePath`) | Delete *.php files (handled by `clearCache()`) |

### File Backend
Twig creates one PHP file per compiled template. Filenames include an md5 segment of the logical template name + environment salt. We heuristically detect compiled presence with `md5(<logical>.twig)` substring scanning during warmup or invalidation.

### CI Cache Backend (Auto)
Implemented via `CICacheAdapter` when the cache service is available. Each compiled template is stored as a JSON payload:
```json
{"t": <unix_timestamp>, "c": "<?php class ... >" }
```
Key format: `<prefix><sha256(className::logicalName)>`

An index key `<prefix>__index` tracks all compiled keys for full clear operations. Prefix is configurable; see section 6.

---
## 2. Compile Index (`compile-index.json` or CI key)
Purpose: Quickly know which logical templates have been compiled without scanning directories.

Stored as simple JSON mapping:
```json
{ "emails/welcome": true, "dashboard/index": true }
```

| Backend | Location / Key | When Written | When Read |
|---------|----------------|--------------|-----------|
| File | `<cachePath>/compile-index.json` | After warmup or successful invalidation removals | On first need (lazy) for listing / warmup |
| CI Cache | `<prefix>compile.index` | Same triggers | Same (lazy) |

Used by:
- Warmup (skip already compiled unless `--force`)
- `listTemplates(true)` for compiled status
- Diagnostics panel / CLI stats

---
## 3. Template Discovery Persistence
The discovery process enumerates all logical template names by walking each configured template directory (namespaced & root). To avoid repeated filesystem traversal we persist:

Artifacts:
- Stats JSON (hits, misses, invalidations, persisted fingerprint)
- Optional snapshot of the full template list + fingerprint (capability: Discovery Snapshot)

Behavior derives from the capability profile:

| Profile | Snapshot Persisted | Preload | APCu Acceleration | Fingerprint Depth |
|---------|--------------------|---------|-------------------|-------------------|
| Full (`leanMode = false`) | Yes | Yes (implicit) | If APCu enabled | Fixed (shallow) |
| Lean (`leanMode = true`) | No (unless `enableDiscoverySnapshot = true`) | Matches snapshot state | If snapshot active && APCu enabled | Fixed (shallow) |

Override: set `$config->enableDiscoverySnapshot = true;` to force the snapshot (and implicit preload/APCu) while still in Lean Mode.

### Fingerprinting Strategy
A stable SHA-1 fingerprint is built from:
1. Canonicalized namespace/path map (sorted, realpath-normalized)
2. Shallow directory `filemtime()` sampling (depth now fixed; deeper sampling removed for simplicity)

If fingerprint matches a persisted snapshot:
- Snapshot (APCu > CI > file) is restored without disk traversal.
- First scan counts as a miss. Subsequent restores count as hits.
- Preload automatically turns that restoration into an early hit when enabled (full profile or lean + override).

### Persistence Locations
| Backend | Stats Key/Path | List Key/Path |
|---------|----------------|---------------|
| File | `WRITEPATH/cache/twig/discovery-stats.json` | `discovery-stats-list.json` | 
| CI Cache | `<prefix>disc.stats` | `<prefix>disc.list` |
| APCu (auto) | `twig.discovery.list.<fingerprint>` | (in-memory only) |

### Metrics
`hits` increase when list reused in-process or restored from snapshot/APCu. `misses` increase when a filesystem scan is performed.

---
## 4. Warmup Summary
Records the most recent warmup results:
```json
{ "summary": {"compiled": 42, "skipped": 100, "errors": 0}, "all": true, "timestamp": 1734567890.123 }
```

| Backend | Location / Key |
|---------|----------------|
| File | `<cachePath>/warmup-summary.json` |
| CI Cache | `<prefix>warmup.summary` |

Used by diagnostics / CLI to show last warmup outcome without rerunning.

---
## 5. Invalidation State
Tracks:
- Last invalidation: type (single / batch / namespace), removed file count, whether environment was reinitialized, timestamp.
- Cumulative removed count across lifecycle.

| Backend | Location / Key |
|---------|----------------|
| File | `<cachePath>/invalidations.json` |
| CI Cache | `<prefix>invalidations` |

Displayed in diagnostics to monitor cache churn and potential performance issues due to frequent invalidations.

---
## 6. Prefix Derivation (CI Backend)
Prefix is auto-derived from `Config\Cache::$prefix` + `twig_`.
Examples:
- Global cache prefix: `app_` → Effective twig prefix: `app_twig_`
- Custom set: `$cachePrefix = 'tenant42_'` → Effective keys start with `tenant42_`

CI Key Summary (with `<prefix>` already resolved):
```
<prefix>disc.stats
<prefix>disc.list
<prefix>warmup.summary
<prefix>compile.index
<prefix>invalidations
<prefix>__index            (CICacheAdapter internal index of compiled template keys)
<prefix><sha256>           (individual compiled template entries)
```

---
## 7. Clearing Everything
`clearCache()` clears compiled artifacts. Behavior differs internally but API is unified:

| Effective Backend | Action | Also Clears | Returns |
|-------------------|--------|-------------|---------|
| File | Deletes PHP files under cache dir | (Manual removal for discovery stats optional) | Count of removed files |
| CI | Clears adapter + deletes: disc.stats, disc.list, warmup.summary, compile.index, invalidations | Discovery stats reset via `invalidate()` | 0 |

To also rebuild the Twig Environment: `clearCache(true)` (forces reinitialization).

For a full fresh state in file backend you may manually remove:
```
rm -rf WRITEPATH/cache/twig
```
(Or Windows equivalent) then let Twig recreate on-demand.

---
## 8. Runtime Cache Control
API methods:
```php
$twig->disableCache();          // turns caching off (filesystem backend)
$twig->disableCache(true);      // also deletes existing compiled files
$twig->enableCache();           // re-enable default path
$twig->enableCache('/custom');  // force custom directory
$twig->isCacheEnabled();        // bool (always true for CI backend)
```
When disabled, Twig renders directly without writing compiled classes (slower per request, good for development).

---
## 9. Warmup & Compile Index Interaction
`warmup()` / `warmupAll()`:
- Loads compile index lazily.
- For each logical name: if already compiled (index OR heuristic file presence) and not forced → skip.
- On successful compilation → mark compiled + persist index.
- Summary persisted for diagnostics.

CLI examples:
```
php spark twig:warmup --all
php spark twig:warmup welcome emails/reset-password
php spark twig:warmup welcome --force
```

Force mode ensures recompilation (refresh) even if previously compiled.

---
## 10. Discovery Performance (Simplified Model)
Manual micro-tuning flags have been removed. Choose a profile:

| Scenario | Recommendation |
|----------|---------------|
| Standard production app | `leanMode = false` (auto snapshot + preload + APCu) |
| High-throughput minimal overhead | `leanMode = true` (no snapshot) |
| Many templates; want speed but still low diagnostics | `leanMode = true` + `enableDiscoverySnapshot = true` |

Rationale: Automatic heuristics eliminate config surface while keeping the fast path enabled for typical deployments.

---
## 11. Diagnostics & Introspection
`$twig->getDiagnostics()` returns a structured array including:
```php
[
  'cache' => [ 'enabled' => true, 'backend' => 'file|ci:<handler>', 'compiled_templates' => 123, ... ],
  'discovery' => [ 'hits' => 10, 'misses' => 1, 'fingerprint' => 'sha1...', 'cache_source' => 'persisted-preload', 'persistence_medium' => 'ci|file', ... ],
  'warmup' => [...],
  'invalidations' => [...],
  'persistence' => [ 'warmup' => ['medium' => 'file'], ... ],
]
```
Expose this in CLI via `twig:diagnostics` (if provided) or integrate into your own admin panel.

---
## 12. Invalidation Mechanics
Three strategies:
1. Single template → remove files containing md5(template + extension)
2. Batch → loop single strategy; aggregate
3. Namespace → derive on-disk relative paths from loader namespace paths & pattern match

After removals:
- Compile index updated (removed entries cleared)
- Invalidation state persisted
- Optional reinitialization if requested

For CI backend: compiled templates are just deleted from the key-value store; no filesystem scanning for removal.

---
## 13. Migration Notes (Switching Backends)
When switching from file → CI backend:
- Compile index is re-seeded from CI key if present.
- Discovery migration attempts to copy JSON stats/list into CI cache if CI keys aren’t yet populated (best-effort).
- Consider clearing file artifacts after validating CI backend works to avoid confusion.

---
## 14. Failure & Safety Behavior
| Scenario | Behavior |
|----------|----------|
| Missing snapshot JSON | Falls back to scan (miss) |
| Corrupt JSON payload | Ignored; treat as absent |
| APCu fetch failure | Ignore and fallback to snapshot or scan |
| CI cache handler exception | Swallowed (fails safe); file path still used for compile index unless backend='ci' |
| Fingerprint mismatch | Forces fresh scan, updates persisted fingerprint |

All persistence operations are best-effort and never throw.

---
## 15. Recommended Production Configuration
```php
// Full profile (default)
$config->leanMode = false; // snapshot + preload + APCu (if available)
```
Large template set but still want trimmed diagnostics:
```php
$config->leanMode = true;
$config->enableDiscoverySnapshot = true; // opt back into snapshot/preload/APCu
```
Run warmup once after deployments:
```
php spark twig:warmup --all
```
Then rely on invalidation commands when templates change at runtime.

---
## 16. Quick Reference Cheatsheet
| Task | Command / API |
|------|---------------|
| Warm all templates | `php spark twig:warmup --all` |
| Warm subset force | `php spark twig:warmup email/welcome --force` |
| List templates | `php spark twig:list` |
| List with status | `php spark twig:list --status` |
| Invalidate single | `php spark twig:invalidate emails/welcome` |
| Invalidate batch | `php spark twig:invalidate:batch a b c` |
| Invalidate namespace | `php spark twig:invalidate @admin` (if command provided) |
| Clear cache only | `php spark twig:clear-cache` |
| Clear & reinit | `php spark twig:clear-cache --reinit` |
| Show stats/diagnostics | `php spark twig:diagnostics` / `twig:stats` (depending on command set) |

---
## 17. Extending / Customizing
You can:
- Wrap `TemplateDiscovery` to add custom exclusion filters.
- Implement another `Twig\Cache\CacheInterface` adapter (e.g. for S3) and assign via config.
- Add health endpoint exposing `getDiagnostics()` for monitoring.

Pull requests for new safe backends & richer diagnostics are welcome.

---
## 18. Troubleshooting
| Symptom | Cause | Resolution |
|---------|-------|-----------|
| Discovery misses always increase | Fingerprint never matches persisted snapshot | Enable snapshot (full profile) or override in lean |
| Warmup skips too many templates | Compile index stale after manual deletions | Run `clearCache(true)` then `warmup --all` |
| CI backend keys not appearing | Cache service misconfigured | Verify `Services::cache()` returns expected handler |
| Compiled templates keep recompiling (file backend) | Cache directory not writable | Fix permissions for `WRITEPATH/cache/twig` |
| High initial latency on first request | No warmup + discovery scan | Run warmup or use full profile (auto snapshot/preload) |

---
## 19. Version Compatibility
- Twig 3.x
- CodeIgniter 4.x
- PHP 8.1+

All caching layers degrade gracefully if a feature (APCu, CI cache) is unavailable.

---
## 20. Glossary
| Term | Meaning |
|------|---------|
| Logical Template Name | Path without extension, optionally prefixed by `@namespace/` |
| Fingerprint | Stable hash representing template directory structure & mtimes |
| Compile Index | Persisted map of logical names known compiled |
| Discovery Snapshot | Serialized template list + matching fingerprint |
| Invalidation | Removal of compiled artifacts for logical templates |

---
Questions / improvements? Open an issue or PR.



---
## 21. Lean Mode & Capability Overrides

Lean Mode is a macro switch designed to minimize IO, persistence writes, and diagnostic payload size in latency‑sensitive or resource‑constrained environments. It disables several non-essential persistence layers and rich diagnostics by default, while still allowing targeted re‑enablement through nullable override flags.

### 21.1 Capabilities Matrix

| Capability | Purpose | Full Profile (leanMode = false) | Lean Profile (leanMode = true) | Override Property (nullable) |
|------------|---------|----------------------------------|--------------------------------|------------------------------|
| Discovery Snapshot | Persist + restore full template list to skip filesystem scans | Enabled (automatic) | Disabled | `enableDiscoverySnapshot` |
| Warmup Summary Persistence | Keep last warmup result for diagnostics/CLI | Enabled | Disabled | `enableWarmupSummary` |
| Invalidation History Persistence | Persist cumulative + last invalidation metadata | Enabled | Disabled | `enableInvalidationHistory` |
| Dynamic Metrics (counts + names) | Show registered dynamic functions/filters details | Enabled | Disabled (counts zeroed) | `enableDynamicMetrics` |
| Extended Diagnostics (names lists) | Includes static/dynamic function & filter name arrays | Enabled | Disabled (names key removed) | `enableExtendedDiagnostics` |

Notes:
1. Overrides are tri‑state: `null` means "use profile default"; `true` forces enable; `false` forces disable.
2. Lean Mode never affects core rendering correctness, compilation, or invalidation logic—only persistence/diagnostic layers.
3. `clearCache()` remains aggressive regardless of profile (simpler mental model): it removes compiled templates and related persisted artifacts if present.

### 21.2 Example Configurations

Minimal production (favor throughput, minimal persistence):
```php
$config->leanMode = true; // all optional persistence off
```

Lean with warmup summary only (e.g. for deployment verification):
```php
$config->leanMode = true;
$config->enableWarmupSummary = true;
```

Lean but keep discovery snapshot for large template sets:
```php
$config->leanMode = true;
$config->enableDiscoverySnapshot = true;   // forces snapshot (preload/APCu implied)
```

Full profile except hiding extended names (reduce payload size only):
```php
$config->leanMode = false; // base = all on
$config->enableExtendedDiagnostics = false; // drop names arrays
```

### 21.3 Operational Guidance

| Scenario | Recommended Profile / Overrides |
|----------|---------------------------------|
| High RPS API where Twig used for a few fragments | `leanMode = true` (+ snapshot only if many templates) |
| Admin panel needing rich observability | `leanMode = false` (default full) |
| CI pipeline warmup job | Either; if lean turn on `enableWarmupSummary = true` to capture result |
| Memory constrained container | `leanMode = true` (fewer retained arrays) |

### 21.4 Diagnostics Differences

When disabled by Lean Mode:
* `warmup` key is `null`.
* `invalidations` key is `null`.
* `dynamic_functions` / `dynamic_filters` counters are reset to `registered = 0` with empty names list.
* `names` section is removed entirely (instead of empty arrays) when extended diagnostics are disabled.

This deterministic shape change allows tooling to quickly infer capability state without separate flags.

---
